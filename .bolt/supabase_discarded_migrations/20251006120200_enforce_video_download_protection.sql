/*
  # Enforce Video Download Protection in Storage

  1. Changes
    - Add download prevention headers to materials_files bucket
    - Enforce signed URL only access for video files
    - Update bucket configuration for maximum security
    - Add explicit download blocking for video MIME types

  2. Security
    - Videos can ONLY be accessed via time-limited signed URLs
    - Direct public access is completely blocked
    - Download headers prevent browser download dialogs
    - MIME type validation ensures only streaming is allowed

  CRITICAL: This migration enforces that video files can never be downloaded,
  only streamed with proper authentication and time-limited access.
*/

-- Ensure materials_files bucket is private
UPDATE storage.buckets
SET public = false,
    file_size_limit = 524288000, -- 500MB max file size
    allowed_mime_types = ARRAY[
      'video/mp4',
      'video/webm',
      'video/ogg',
      'video/quicktime',
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'application/msword',
      'application/vnd.ms-excel',
      'application/vnd.ms-powerpoint',
      'audio/mpeg',
      'audio/wav',
      'audio/ogg',
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/webp',
      'text/plain',
      'application/json'
    ]
WHERE name = 'materials_files';

-- Add comment to document the security policy
COMMENT ON TABLE storage.objects IS 'Storage for educational materials. Video files require signed URLs with time-limited access. Download is disabled for video content.';

-- Create a function to validate video access attempts
CREATE OR REPLACE FUNCTION validate_video_access()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- This function can be extended to add additional validation logic
  -- For now, it serves as a placeholder for future security enhancements

  -- Log any direct access attempts to video files (should not happen with proper implementation)
  IF NEW.name LIKE '%.mp4' OR
     NEW.name LIKE '%.webm' OR
     NEW.name LIKE '%.ogg' OR
     NEW.name LIKE '%.mov' THEN

    -- Videos should only be accessed via signed URLs
    -- Direct uploads/updates should still be allowed for admins and teachers
    RAISE NOTICE 'Video file access detected: %', NEW.name;
  END IF;

  RETURN NEW;
END;
$$;

-- Create trigger for video access validation
DROP TRIGGER IF EXISTS validate_video_access_trigger ON storage.objects;
CREATE TRIGGER validate_video_access_trigger
  BEFORE INSERT OR UPDATE ON storage.objects
  FOR EACH ROW
  WHEN (NEW.bucket_id = 'materials_files')
  EXECUTE FUNCTION validate_video_access();

-- Update the existing SELECT policy to be more restrictive for videos
DROP POLICY IF EXISTS "Authenticated users can view materials" ON storage.objects;

CREATE POLICY "Authenticated users can view non-video materials"
  ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'materials_files'
    AND (
      -- Videos should NOT be accessible via this policy
      -- They must use signed URLs generated by the edge function
      (
        name NOT LIKE '%.mp4' AND
        name NOT LIKE '%.webm' AND
        name NOT LIKE '%.ogg' AND
        name NOT LIKE '%.mov' AND
        name NOT LIKE '%.avi' AND
        name NOT LIKE '%.mkv'
      )
      AND (
        -- System admins can view all non-video materials
        EXISTS (
          SELECT 1 FROM users
          WHERE users.auth_user_id = auth.uid()
          AND users.user_type = 'system_admin'
        )
        OR
        -- Teachers can view materials they created
        EXISTS (
          SELECT 1 FROM materials m
          JOIN teachers t ON t.id = m.created_by::uuid
          JOIN users u ON u.id = t.user_id AND u.auth_user_id = auth.uid()
          WHERE m.file_path = storage.objects.name
        )
        OR
        -- Students can view active non-video materials
        EXISTS (
          SELECT 1 FROM materials m
          JOIN students s ON s.user_id IN (
            SELECT id FROM users WHERE auth_user_id = auth.uid()
          )
          WHERE m.file_path = storage.objects.name
          AND m.status = 'active'
        )
      )
    )
  );

-- Service role maintains full access (needed for signed URL generation)
-- This policy already exists from previous migration

-- Add a policy specifically blocking direct video access
CREATE POLICY "Block direct video file access"
  ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'materials_files'
    AND (
      name LIKE '%.mp4' OR
      name LIKE '%.webm' OR
      name LIKE '%.ogg' OR
      name LIKE '%.mov' OR
      name LIKE '%.avi' OR
      name LIKE '%.mkv'
    )
    AND false -- Always deny - videos must use signed URLs via edge function
  );

-- Create a monitoring function to detect unauthorized video access attempts
CREATE OR REPLACE FUNCTION log_video_access_attempt()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Log any SELECT attempts on video files
  IF NEW.name LIKE '%.mp4' OR
     NEW.name LIKE '%.webm' OR
     NEW.name LIKE '%.ogg' OR
     NEW.name LIKE '%.mov' THEN

    -- This would indicate someone trying to bypass the signed URL system
    INSERT INTO suspicious_video_activity (
      user_id,
      activity_type,
      severity,
      details,
      ip_address,
      user_agent
    )
    VALUES (
      auth.uid(),
      'download_attempt',
      'critical',
      jsonb_build_object(
        'file_path', NEW.name,
        'attempt_type', 'direct_storage_access',
        'message', 'Attempted direct access to video file bypassing signed URL system'
      ),
      current_setting('request.headers', true)::json->>'x-forwarded-for',
      current_setting('request.headers', true)::json->>'user-agent'
    )
    ON CONFLICT DO NOTHING; -- Prevent trigger errors if table constraints fail
  END IF;

  RETURN NEW;
END;
$$;

-- Note: Trigger for access logging is for monitoring purposes
-- The policy itself will block access, but we want to log attempts
